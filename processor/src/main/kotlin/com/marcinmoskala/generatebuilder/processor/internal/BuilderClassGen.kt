package com.marcinmoskala.generatebuilder.processor.internal

import com.marcinmoskala.generatebuilder.processor.ProcessingException
import com.marcinmoskala.generatebuilder.processor.getClassName
import com.marcinmoskala.generatebuilder.processor.getGeneratedSourcesRoot
import com.squareup.kotlinpoet.*
import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
import java.io.File
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.TypeElement
import kotlin.properties.Delegates

internal fun ProcessingEnvironment.generateClass(targetType: TargetType, metadata: KotlinClassMetadata) {
    val classElement = targetType.element
    val packageOfClass = this.elementUtils.getPackageOf(classElement).toString()
    val builderClassName = targetType.builderName

    val generatedSourcesRoot: String = getGeneratedSourcesRoot()
    if (generatedSourcesRoot.isEmpty()) {
        throw ProcessingException(
            classElement,
            "Can't find the target directory for generated Kotlin files."
        )
    }
    val file = File(generatedSourcesRoot)
    file.mkdir()
    val fileSpec = FileSpec.builder(packageOfClass, builderClassName)

    val classBuilderClassName = getClassName(classElement, builderClassName)

    fileSpec.addComment("Code generated by GenerateBuilder. Do not edit.")

    val classBuilder = createBuilderClass(
        builderClassName,
        targetType,
        classElement,
        metadata,
        classBuilderClassName
    )

    fileSpec.addType(classBuilder.build())
        .build().writeTo(file)
}

private fun createBuilderClass(
    builderClassName: String,
    targetType: TargetType,
    classElement: TypeElement,
    metadata: KotlinClassMetadata,
    classBuilderClassName: ClassName
): TypeSpec.Builder {
    val classBuilder = TypeSpec.classBuilder(builderClassName)
        .primaryConstructor(FunSpec.constructorBuilder().build())

    if (targetType.isInternal) {
        classBuilder.addModifiers(KModifier.INTERNAL)
    }

    val classElementTypeName = classElement.asType().asTypeName()

    val properties = targetType.constructor.parameters
        .map {
            GenerateBuilderProperty(
                it.key,
                it.value,
                targetType.proto,
                metadata.data.nameResolver
            )
        }

    // Add properties
    properties.forEach { classBuilder.addProperty(
        createPropertySpec(
            it
        )
    ) }

    // Add constructors
    classBuilder.addCopyingConstructor(classElementTypeName, properties)
    classBuilder.addValuesConstructor(properties)

    // Add with* functions
    properties.forEach { property ->
        classBuilder.addWithMethod(property, classBuilderClassName)
    }

    // Add build function
    classBuilder.addBuildFunction(classElementTypeName, targetType)
    return classBuilder
}

private fun TypeSpec.Builder.addBuildFunction(classElementTypeName: TypeName, targetType: TargetType) {
    val buildFunSpec = FunSpec.builder("build")
        .returns(classElementTypeName)
        .addStatement("return $classElementTypeName(${targetType.constructor.parameters.keys.joinToString { it }})")
        .build()
    addFunction(buildFunSpec)
}

private fun TypeSpec.Builder.addWithMethod(property: GenerateBuilderProperty, classBuilderClassName: ClassName) {
    val propertyName = property.name
    val paramName = "new" + propertyName.capitalize()
    addFunction(
        FunSpec.builder("with${propertyName.capitalize()}")
            .addParameter(paramName, property.typeName)
            .returns(classBuilderClassName)
            .addStatement("return this.apply { this.$propertyName = $paramName }").build()
    )
}

private fun TypeSpec.Builder.addCopyingConstructor(classElementTypeName: TypeName, properties: List<GenerateBuilderProperty>) {
    var constructorSpec = FunSpec.constructorBuilder()
        .callThisConstructor()
        .addParameter("instance", classElementTypeName)
    for (property in properties) {
        constructorSpec = constructorSpec
            .addStatement("this.${property.name} = instance.${property.name}")
    }
    addFunction(constructorSpec.build())
}

private fun TypeSpec.Builder.addValuesConstructor(properties: List<GenerateBuilderProperty>) {
    if(properties.isEmpty()) return
    var constructorSpec = FunSpec.constructorBuilder()
        .callThisConstructor()
    for (property in properties) {
        constructorSpec = constructorSpec
            .addParameter(property.name, property.typeName)
            .addStatement("this.${property.name} = ${property.name}")
    }
    addFunction(constructorSpec.build())
}

private fun createPropertySpec(param: GenerateBuilderProperty): PropertySpec {
    val propBuilder = PropertySpec.builder(param.name, param.typeName).mutable()
    if (param.isNullable()) {
        // nullable element
        propBuilder.initializer("null")
    } else {
        // non null element
        propBuilder.delegate("%T.notNull()", Delegates::class)
    }
    return propBuilder.build()
}

